import AsyncStorage from "@react-native-async-storage/async-storage";
import React, { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState } from "react";

import {
  authGuest,
  authLogin,
  authMe,
  authProvider,
  authRegister,
  authRequestPasswordResetCode,
  authResetPassword,
  authUpdateProfile,
  authVerifyPasswordResetCode,
  setAuthToken,
} from "@/src/lib/api";
import { AuthUser } from "@/src/types";

export type AuthMethod = "guest" | "google" | "apple" | "phone" | "password";

interface PhoneOtpState {
  code: string;
  expiresAt: number;
  attempts: number;
}

interface AuthContextValue {
  isHydrated: boolean;
  user: AuthUser | null;
  token: string | null;
  isSignedIn: boolean;
  signInAsGuest: () => Promise<void>;
  signUpWithPassword: (email: string, password: string) => Promise<void>;
  signInWithPassword: (email: string, password: string) => Promise<void>;
  signInWithGoogle: (input: {
    id: string;
    name?: string | null;
    email?: string | null;
    avatar?: string | null;
    idToken?: string | null;
  }) => Promise<void>;
  signInWithApple: (input: {
    id: string;
    name?: string | null;
    email?: string | null;
    identityToken?: string | null;
  }) => Promise<void>;
  sendPhoneCode: (phone: string) => Promise<{ expiresAt: number; devCode?: string }>;
  verifyPhoneCode: (phone: string, code: string) => Promise<void>;
  requestPasswordResetCode: (email: string) => Promise<{
    message?: string;
    expiresAt?: string;
    verificationCode?: string;
    devCode?: string;
    retryAfterSeconds?: number;
  }>;
  verifyPasswordResetCode: (email: string, code: string) => Promise<{ resetToken: string; resetTokenExpiresAt?: string }>;
  resetPassword: (input: { email: string; resetToken: string; password: string }) => Promise<{ ok?: boolean; message?: string }>;
  completeProfile: (input: { displayName: string; email: string }) => Promise<void>;
  signOut: () => Promise<void>;
}

interface PersistedSession {
  token: string;
  user: AuthUser;
}

const SESSION_KEY = "agenttown.auth.session.v2";
const OTP_TTL_MS = 5 * 60 * 1000;
const OTP_MAX_ATTEMPTS = 5;

const AuthContext = createContext<AuthContextValue | null>(null);

export function normalizePhone(phone: string) {
  const value = phone.trim().replace(/[^\d+]/g, "");
  if (!value || value.length < 7) {
    throw new Error("请输入有效手机号");
  }
  return value;
}

export function displayNameFromEmail(email?: string | null) {
  if (!email) return null;
  const [local] = email.split("@");
  return local || null;
}

export function defaultDisplayNameForEmail(email: string) {
  return displayNameFromEmail(email.trim()) || "Member";
}

function mapBackendUser(input: {
  id: string;
  provider: string;
  displayName: string;
  email?: string;
  requireProfileSetup?: boolean;
  role?: "admin" | "member" | "guest";
  createdAt: string;
  updatedAt?: string;
}): AuthUser {
  return {
    id: input.id,
    provider: (input.provider as AuthMethod) || "guest",
    displayName: input.displayName,
    email: input.email,
    requireProfileSetup: Boolean(input.requireProfileSetup),
    role: input.role || "guest",
    createdAt: input.createdAt,
    updatedAt: input.updatedAt,
  };
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [isHydrated, setIsHydrated] = useState(false);
  const [user, setUser] = useState<AuthUser | null>(null);
  const [token, setToken] = useState<string | null>(null);
  const otpMapRef = useRef<Map<string, PhoneOtpState>>(new Map());

  const persistSession = useCallback(async (next: PersistedSession | null) => {
    if (!next) {
      await AsyncStorage.removeItem(SESSION_KEY);
      return;
    }
    await AsyncStorage.setItem(SESSION_KEY, JSON.stringify(next));
  }, []);

  const applySession = useCallback(
    async (next: PersistedSession | null, persist = true) => {
      setUser(next?.user || null);
      setToken(next?.token || null);
      setAuthToken(next?.token || null);
      if (persist) {
        await persistSession(next);
      }
    },
    [persistSession]
  );

  useEffect(() => {
    let alive = true;

    (async () => {
      try {
        const raw = await AsyncStorage.getItem(SESSION_KEY);
        if (!raw) return;

        const parsed = JSON.parse(raw) as Partial<PersistedSession>;
        if (!parsed?.token || !parsed?.user?.id) {
          await AsyncStorage.removeItem(SESSION_KEY);
          return;
        }

        await applySession(
          {
            token: parsed.token,
            user: parsed.user,
          },
          false
        );

        try {
          const me = await authMe();
          if (!alive) return;
          await applySession({ token: parsed.token, user: mapBackendUser(me) });
        } catch {
          if (!alive) return;
          await applySession(null);
        }
      } catch {
        await AsyncStorage.removeItem(SESSION_KEY);
      } finally {
        if (alive) {
          setIsHydrated(true);
        }
      }
    })();

    return () => {
      alive = false;
    };
  }, [applySession]);

  const signInAsGuest = useCallback(async () => {
    const session = await authGuest("Guest Explorer");
    await applySession({
      token: session.token,
      user: mapBackendUser(session.user),
    });
  }, [applySession]);

  const signUpWithPassword = useCallback<AuthContextValue["signUpWithPassword"]>(
    async (email, password) => {
      const normalizedEmail = email.trim();
      const session = await authRegister({
        email: normalizedEmail,
        password,
        displayName: defaultDisplayNameForEmail(normalizedEmail),
      });
      await applySession({ token: session.token, user: mapBackendUser(session.user) });
    },
    [applySession]
  );

  const signInWithPassword = useCallback<AuthContextValue["signInWithPassword"]>(
    async (email, password) => {
      const session = await authLogin({ email: email.trim(), password });
      await applySession({ token: session.token, user: mapBackendUser(session.user) });
    },
    [applySession]
  );

  const requestPasswordResetCode = useCallback<AuthContextValue["requestPasswordResetCode"]>(async (email) => {
    return authRequestPasswordResetCode({ email: email.trim() });
  }, []);

  const verifyPasswordResetCode = useCallback<AuthContextValue["verifyPasswordResetCode"]>(
    async (email, code) => {
      return authVerifyPasswordResetCode({ email: email.trim(), code: code.trim() });
    },
    []
  );

  const resetPassword = useCallback<AuthContextValue["resetPassword"]>(async (input) => {
    return authResetPassword({
      email: input.email.trim(),
      resetToken: input.resetToken.trim(),
      password: input.password,
    });
  }, []);

  const signInWithGoogle = useCallback<AuthContextValue["signInWithGoogle"]>(
    async (input) => {
      const normalizedName = input.name?.trim() || displayNameFromEmail(input.email) || undefined;
      const session = await authProvider({
        provider: "google",
        providerUserId: input.id,
        idToken: input.idToken || undefined,
        email: input.email || undefined,
        displayName: normalizedName,
      });
      const mapped = mapBackendUser(session.user);
      mapped.avatar = input.avatar || undefined;
      await applySession({ token: session.token, user: mapped });
    },
    [applySession]
  );

  const signInWithApple = useCallback<AuthContextValue["signInWithApple"]>(
    async (input) => {
      const normalizedName = input.name?.trim() || displayNameFromEmail(input.email) || undefined;
      const session = await authProvider({
        provider: "apple",
        providerUserId: input.id,
        idToken: input.identityToken || undefined,
        email: input.email || undefined,
        displayName: normalizedName,
      });
      await applySession({ token: session.token, user: mapBackendUser(session.user) });
    },
    [applySession]
  );

  const completeProfile = useCallback<AuthContextValue["completeProfile"]>(
    async ({ displayName, email }) => {
      const session = await authUpdateProfile({ displayName, email });
      await applySession({
        token: session.token,
        user: mapBackendUser(session.user),
      });
    },
    [applySession]
  );

  const sendPhoneCode = useCallback<AuthContextValue["sendPhoneCode"]>(async (phone) => {
    const normalizedPhone = normalizePhone(phone);
    const nextCode = `${Math.floor(100000 + Math.random() * 900000)}`;
    const expiresAt = Date.now() + OTP_TTL_MS;

    otpMapRef.current.set(normalizedPhone, {
      code: nextCode,
      expiresAt,
      attempts: 0,
    });

    return {
      expiresAt,
      devCode: __DEV__ ? nextCode : undefined,
    };
  }, []);

  const verifyPhoneCode = useCallback<AuthContextValue["verifyPhoneCode"]>(
    async (phone, code) => {
      const normalizedPhone = normalizePhone(phone);
      const normalizedCode = code.trim();
      const record = otpMapRef.current.get(normalizedPhone);
      if (!record) {
        throw new Error("验证码已失效，请重新发送");
      }
      if (Date.now() > record.expiresAt) {
        otpMapRef.current.delete(normalizedPhone);
        throw new Error("验证码已过期，请重新发送");
      }
      if (normalizedCode !== record.code) {
        record.attempts += 1;
        if (record.attempts >= OTP_MAX_ATTEMPTS) {
          otpMapRef.current.delete(normalizedPhone);
        } else {
          otpMapRef.current.set(normalizedPhone, record);
        }
        throw new Error("验证码错误");
      }

      otpMapRef.current.delete(normalizedPhone);
      const session = await authProvider({
        provider: "phone",
        providerUserId: normalizedPhone,
        displayName: `User-${normalizedPhone.slice(-4)}`,
      });

      const mapped = mapBackendUser(session.user);
      mapped.phone = normalizedPhone;
      await applySession({ token: session.token, user: mapped });
    },
    [applySession]
  );

  const signOut = useCallback(async () => {
    await applySession(null);
  }, [applySession]);

  const value = useMemo<AuthContextValue>(
    () => ({
      isHydrated,
      user,
      token,
      isSignedIn: Boolean(user && token && !user.requireProfileSetup),
      signInAsGuest,
      signUpWithPassword,
      signInWithPassword,
      signInWithGoogle,
      signInWithApple,
      sendPhoneCode,
      verifyPhoneCode,
      requestPasswordResetCode,
      verifyPasswordResetCode,
      resetPassword,
      completeProfile,
      signOut,
    }),
    [
      isHydrated,
      user,
      token,
      signInAsGuest,
      signUpWithPassword,
      signInWithPassword,
      signInWithGoogle,
      signInWithApple,
      sendPhoneCode,
      verifyPhoneCode,
      requestPasswordResetCode,
      verifyPasswordResetCode,
      resetPassword,
      completeProfile,
      signOut,
    ]
  );

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

export function useAuth() {
  const value = useContext(AuthContext);
  if (!value) {
    throw new Error("useAuth must be used inside AuthProvider");
  }
  return value;
}
